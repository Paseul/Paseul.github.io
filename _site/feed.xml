<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-12-28T09:30:48+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Paseul’s Devlog</title><subtitle>C#, Python, Docker, Kubernetes, Deep learning, Reinforcement learning</subtitle><author><name>Jaehoon Lee</name><email>machianb@naver.com</email></author><entry><title type="html">5G 국제 표준의 이해</title><link href="http://localhost:4000/networks/5g-nr-standards/" rel="alternate" type="text/html" title="5G 국제 표준의 이해" /><published>2019-12-27T00:00:00+09:00</published><updated>2019-12-27T00:00:00+09:00</updated><id>http://localhost:4000/networks/5g-nr-standards</id><content type="html" xml:base="http://localhost:4000/networks/5g-nr-standards/">&lt;p&gt;본 포스팅은 삼성에서 제공한 &lt;a href=&quot;https://images.samsung.com/is/content/samsung/p5/global/business/networks/insights/white-paper/who-and-how_making-5g-nr-standards/who-and-how_making-5g-nr-standards_KR.pdf&quot;&gt;5G 국제 표준의 이해&lt;/a&gt;를 요약 정리한 포스팅 입니다&lt;/p&gt;
&lt;h2 id=&quot;5g-nrnew-radio-표준&quot;&gt;5G NR(New Radio) 표준&lt;/h2&gt;
&lt;h3 id=&quot;표준&quot;&gt;&lt;strong&gt;표준&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;표준(Standardization)을 통하여 특정 국가나 사업자에게만 특화된 제품이 아니라 전세계에서 통용되는 제품을 생산할 수 있게 된다.
과거에는 국가별, 제조사별, 표준화 단체별로 제품을 개발하여 시장을 많이 점유한 기술이 사실상(De-facto) 국제표준이 되기도 했으나 최근에는 이러한 규격을 표준화하여 국제적으로 합의된 국제 표준을 사용하고 있다.&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;국제 표준을 통해&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;R&amp;amp;D 비용 절감&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;소비자는&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;통신기능 주체간에 정보교환 및 신호 처리가 가능&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제조사는 대량생산, 중복투자 방지, 기술이전, 가능&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제조사간의 경쟁을 통해 가성비 높은 제품을 확보&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Generation 구분:&lt;/strong&gt;  각 세대를 구분 짓는 것은 새로운 서비스가 아니라, 그런 서비스를 가능하게 한 &lt;strong&gt;‘기술적 혁신’&lt;/strong&gt; 새로운 이동통신 기술 혁신들은 바로 각 세대의 &lt;strong&gt;“표준”&lt;/strong&gt;에 의해 정의되어 왔다.&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;5g-표준&quot;&gt;&lt;strong&gt;5G 표준&lt;/strong&gt;&lt;/h3&gt;
&lt;center&gt;&lt;img src=&quot;/assets/images/Networks/ITU-3GPP_relationship.PNG&quot; width=&quot;60%&quot; /&gt;&lt;/center&gt;

&lt;dl&gt;
  &lt;dt&gt;&lt;strong&gt;ITU(국제 전기 통신 연합, International Telecommunication Union)&lt;/strong&gt; 에서 비전 및 목표를 제시하고  &lt;strong&gt;국제 표준화 단체(3GPP)&lt;/strong&gt; 에서 기술 표준 개발&lt;/dt&gt;
  &lt;dt&gt;&lt;strong&gt;3GPP&lt;/strong&gt;는 전세계 이동통신 사업자, 장비 제조사, 단말 제조사, 칩 제조사 및 세계 각국의 표준화 단체와 연구기관 등 약 500여개 업체가 참여하는 최대 국제 이동통신 표준화 단체&lt;br /&gt;&lt;/dt&gt;
  &lt;dt&gt;&lt;strong&gt;5G 표준의 특징&lt;/strong&gt;&lt;/dt&gt;
  &lt;dt&gt;1) 초 광대역 서비스 (eMBB: enhanced Mobile Broadband)&lt;/dt&gt;
  &lt;dd&gt;사용자당 100Mbps에서 최대 20Gbps까지 훨씬 빠른 데이터 전송속도 제공을 목표
2) 고신뢰/초저지연 통신 (URLLC: Ultra Reliable &amp;amp; Low Latency Communications)&lt;/dd&gt;
  &lt;dd&gt;기존 수십 밀리 세컨드 (1ms = 1/1000 초) 걸리던 지연 시간을 1ms 수준으로 최소화하는 것을 목표
3) 대량연결 (mMTC: Machine-Type Communications)&lt;/dd&gt;
  &lt;dd&gt;1 km2 면적 당1백만개의 연결(connection)을 지원하는 것을 목표&lt;/dd&gt;
&lt;/dl&gt;

&lt;center&gt;&lt;img src=&quot;/assets/images/Networks/4Gvs5G.PNG&quot; width=&quot;70%&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;4G LTE도 초기 상용화 시점(2010년 경) 당시 최대속도가 75Mbps였고 2018년에야 목표성능 1Gbps 상용이 가능 했고 5G도 마찬가지일 것으로 예상된다&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;4G의 주파수 대역은  6GHz 이하(Below 6GHz)였지만 28GHz와 39GHz 등 밀리미터파(mmWave)로 불리는 초고주파 대역(Above 6GHz)까지 함께 사용하게 된다&lt;/em&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;빔 포밍 기술:&lt;/strong&gt; 많은 수의 안테나에 실리는 신호를 각각 정밀하게 제어하여 특정 방향으로 에너지를 집중시키거나 또는 반대로 특정 방향으로는 에너지가 가지 않도록 조절이 가능한 기술. 전파의 에너지를 집중시켜 거리를 늘리고 빔(Beam)간에는 간섭을 최소화 시킬 수 있다. 이렇게 예리한 빔을 계속 정확하게 추적(tracking) 해야 하는 것이 기술적 관건이 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img src=&quot;/assets/images/Networks/Beamforming.PNG&quot; width=&quot;80%&quot; /&gt;&lt;/center&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Massive MIMO:&lt;/strong&gt; 수 많은 안테나 배열(Massive Antenna Array)을 활용하여 같은 무선 자원을 여러명이 동시에 사용하는 기술. 4G에서의 MIMO기술은 1차원(1D) 안테나 배열을 사용하였기 때문에 자유도(degree of freedom)가 낮아 수평방향(horizontal)사용자만 구분 했지만 5G에서는 수십개 이상의 안테나를 2차원(2D)으로 배치해 수직-수평(horizontal &amp;amp; vertical)방향 모두 사용자를 구분할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img src=&quot;/assets/images/Networks/MassiveMIMO.PNG&quot; width=&quot;80%&quot; /&gt;&lt;/center&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Network Slicing:&lt;/strong&gt; 4G에서는 Voice와 Data 서비스로 구분해서 Voice에 대해서만 별도의 Qos(Quality-of-Service)를 제공했지만, 5G에서는 네트워크 슬라이싱을 통해 각각의 Data 서비스들도 독립적인 네트워크 자원 할당이 가능하고 따라서 각 서비스별로 다른 서비스의 영향을 받지 않으면서 품질을 보장할 수 있다. &lt;strong&gt;특히, 시간지연에 민감한 서비스(Mission Critical Service)들의 품질을 보장할수 있게 되어 이동통신 사업자는 특화 서비스에 대한 별도의 과금체계도 도입할 수 있다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img src=&quot;/assets/images/Networks/NetworkSlicing.PNG&quot; width=&quot;80%&quot; /&gt;&lt;/center&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;NSA와 SA:&lt;/strong&gt; NAS(Non-Standalone)는 초기 상용망에 구현괄 것으로 예상되는 구조로, 단말의 이동성(mobility) 관리 등을 제어하는 제어 플레인(control plane)의 동작은 4G LTE 망을 활용하면서 사용자 플레인(User plane/Data plane)에 해당하는 데이터 트래픽은 5G 망으로 주고 받는다. SA(Standalone) 구조는 제어 채널이나 데이터 채널 모두 5G의 자체구조를 사용하는 구조이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img src=&quot;/assets/images/Networks/NSA-SA.PNG&quot; width=&quot;80%&quot; /&gt;&lt;/center&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;표준의 Release 개념:&lt;/strong&gt; &lt;strong&gt;Release는 3GPP의 시간 스케쥴이다.&lt;/strong&gt; 이동통신 국제 표준은 단기간에 1회성으로 정해지는 것이 아니며 장기간에 걸쳐 수 차례 업그레이드 된다. 다음 세대가 나오더라도 수년정도는 이전 세대 기술이 계속 보완하여 발표(Release) 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;img src=&quot;/assets/images/Networks/Release.PNG&quot; width=&quot;80%&quot; /&gt;&lt;/center&gt;</content><author><name>Jaehoon Lee</name><email>machianb@naver.com</email></author><category term="Networks" /></entry><entry><title type="html">신경망 아키텍처</title><link href="http://localhost:4000/deeplearning/neural-network-architecture/" rel="alternate" type="text/html" title="신경망 아키텍처" /><published>2019-12-09T00:00:00+09:00</published><updated>2019-12-09T00:00:00+09:00</updated><id>http://localhost:4000/deeplearning/neural-network-architecture</id><content type="html" xml:base="http://localhost:4000/deeplearning/neural-network-architecture/">&lt;h1 id=&quot;신경망-아키텍처&quot;&gt;신경망 아키텍처&lt;/h1&gt;
&lt;h2 id=&quot;mlp&quot;&gt;MLP&lt;/h2&gt;
&lt;p&gt;다층 퍼셉트론(multilayer perceptron, MLP)은 신경망 아키텍처의 가장 기본적인 형태로서 신경 유닛은 층층이 배열되고 인접한 네트워크 층은 전체가 모두 연결된다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://missinglink.ai/wp-content/uploads/2018/11/multilayer-perceptron.png&quot; alt=&quot;출처: https://missinglink.ai/guides/neural-network-concepts/perceptrons-and-multi-layer-perceptrons-the-artificial-neuron-at-the-core-of-deep-learning/&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;autoencoder&quot;&gt;Autoencoder&lt;/h2&gt;
&lt;p&gt;오토인코더 신경망(Autoencoder)의 목표값은 입력값과 동일하게 설정된다. 은닉층당 유닛 수가 점진적으로 증가하기 전에 특정 시점까지 점진적으로 감소하고, 최종 층의 차원은 입력 차원과 동일하다. 은닉층의 앞쪽 절반을 인코더(encoder) 뒤쪽 절반을 디코더(decoder)라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/2/28/Autoencoder_structure.png/350px-Autoencoder_structure.png&quot; alt=&quot;출처: https://en.wikipedia.org/wiki/Autoencoder&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;vaes&quot;&gt;VAEs&lt;/h2&gt;
&lt;p&gt;변분 오토인코더(variational autoencoders, VAEs)의 디코더 부분은 오토 인코더와 동일하고 인코더 부분에서 확률층(noise)를 추가하여 여러 샘플을 얻어서 최대 가능도로 손실함수를 도출한다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/1664/1*eRcdr8gczweQHk--1pZF9A@2x.png&quot; alt=&quot;출처: https://towardsdatascience.com/understanding-variational-autoencoders-vaes-f70510919f73&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;gan&quot;&gt;GAN&lt;/h2&gt;
&lt;p&gt;적대적 신경망(Generatice Adversarial Networks, GAN)에는 생성기 신경망과 판별기 신경망이 있다. 생성기 네트워크는 임의의 소음을 입력받아 데이터 샘플을 생성하려고 시도한다. 판별기 네트워크는 생성된 데이터를 실제 데이터와 비교하고 생성된 데이터가 가짜인지 아닌지에 대한 이진 분류 문제를 시그모이드 출력 활성화를 사용해 해결한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://developers.google.com/machine-learning/gan/images/gan_diagram_discriminator.svg&quot; alt=&quot;출처: https://developers.google.com/machine-learning/gan/discriminator&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;lenet&quot;&gt;LeNet&lt;/h2&gt;
&lt;p&gt;1998년에 설계한 7단계 합성곱 네트워크로, 숫자 분류에 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://notebooks.azure.com/rodolfoferro/libraries/KerasMNIST/raw/LeNet-5.png&quot; alt=&quot;출처: https://notebooks.azure.com/rodolfoferro/projects/KerasMNIST/html/MNIST%20-%20CNN%20Model.ipynb&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;alexnet&quot;&gt;AlexNet&lt;/h2&gt;
&lt;p&gt;2012년 ILSVRC우승팀의 아키텍처. LeNet과 매우 유사한 아키텍처를 가지고 있지만, 층당 필터가 더 많고 깊다. 또한 항상 대체된 합성곱 풀링 대신 스택 합성곱을 사용한다. 작은 합성곱의 스택은 합성곱층의 하나로 된 커다란 수용 영역보다 낫다. 더 많은 비선형성과 더 적은 파라미터를 도입하기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://openresearch.ai/uploads/default/original/1X/b25dce7cb47b0a80b3631d10476a630df4b1f2ff.jpg&quot; alt=&quot;출처: Alexnet 논문&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;zfnet&quot;&gt;ZFNet&lt;/h2&gt;
&lt;p&gt;2013년 ILSVRC 우승팀의 아키텍처. AlexNet을 향상시키기 위해 아키텍처 하이퍼 파라미터를 조정했는데, 특히 중간 합성곱층의 크기를 확장하고 첫 번째 층의 스트라이드와 필터 크기를 작게 함으로써 11x11 스트라이드 4인 AlexNet이 7x7 스트라이드 2인 ZFNet으로 변경됐다. 이렇게 시도한 이유는 첫 번째 합성곱층의 필터 크기가 작으면 많은 원본 픽셀 정보를 유지하는 데 도움이 되기 때문이다. 또한 AlexNet은 1,500만 개의 이미지에 대한 훈련을 받았지만, ZFNet은 130만 개의 이미지에 대해서만 훈련을 받았다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;amp;fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F9937CC415AED57D7160153&quot; alt=&quot;출처: ZFNet 논문&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;googlenet&quot;&gt;GoogLeNet&lt;/h2&gt;
&lt;p&gt;2014년 ILSVRC 우승팀의 아키텍처. GoogLeNet은 CNN을 사용해 인셉션층(Inception layer)이라는 새로운 아키텍처의 구성요소를 도입했다. 인셉션 층은 더 큰 합성곱을 사용하고 더 작은 정보의 이미지에도 정밀한 해상도를 유지할 수 있기 때문에 적용되었다.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;/assets/images/DeepLearning/GoogLeNet.png&quot; width=&quot;80%&quot; /&gt;&lt;/center&gt;

&lt;h2 id=&quot;vgg&quot;&gt;VGG&lt;/h2&gt;
&lt;p&gt;2014년 ILSVRC 준우승팀의 아키텍처. VGG 네트워크는 단순함이 그 특징인데, 3x3 합성곱층만 사용해 쌓아올렸다. 부피를 줄이는 것은 Max Pooling으로 처리된다. 마지막에는 4,096개의 노드가 있는 두 개의 전체가 연결된 층에 소프트맥스 층이 이어진다. 입력에 대한 전처리는 훈련 세트에서 계산된 평균 RGB 값을 각 픽셀에서 빼는 것이다. 풀링은 일부 합성곱층을 따르는 Max Pooling에 의해 이루어 진다. 모든 합성곱층 다음에 Max Pooling이 이어지는 것은 아니다. Max Pooling은 스트라이드가 2인 2x2 픽셀 윈도에서 이루어진다. ReLU 활성화는 각각의 은닉층에서 사용된다. 필터의 수는 대부분 VGG 변형에서 깊이에 따라 증가한다. 16층은 VGG-16, 19층은 VGG-19.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;/assets/images/DeepLearning/VGG16.png&quot; width=&quot;60%&quot; /&gt;&lt;/center&gt;

&lt;h2 id=&quot;resnet&quot;&gt;ResNet&lt;/h2&gt;
&lt;p&gt;2015년 ILSVRC 우승팀의 아키텍처. 잔차 신경망(Residual Neural Network: ResNet)은 연결 건너뛰기와 배치 정규화를 사용하는 새로운 CNN 아키텍처로서 이를 통해 VGG 네트워크보다 복잡성이 낮은데도 152층의 신경망을 훈련할 수 있었다.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;/assets/images/DeepLearning/ResNet.png&quot; width=&quot;80%&quot; /&gt;&lt;/center&gt;

&lt;h2 id=&quot;capsnet&quot;&gt;CapsNet&lt;/h2&gt;
&lt;p&gt;캡슐 네트워크(CapsNet)는 CNN의 스칼라 출력 함수 감지기를 벡터 출력 캡슐로 대체한다. 또 라우팅별로 Max Pooling을 사용한다&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;/assets/images/DeepLearning/CapsNet.jpg&quot; /&gt;&lt;/center&gt;

&lt;h2 id=&quot;rnn&quot;&gt;RNN&lt;/h2&gt;
&lt;p&gt;순환 신경망(recurrent neural Network, RNN)은 시퀀스를 처리하는 데 특화돼 있다. 예를 들어, 주어진 최근 시퀀스로부터 다음 시퀀스에 있는 용어를 예측하거나 한 언어에서 다른 언어로 단어의 시퀀스를 번역하려는 경우, 시퀀스 모델링을 할 필요가 있다. RNN은 아키텍처에 피드백 루프가 있다는 점에서 전방 전달 네트워크와 구별된다. 종종 RNN에는 메모리가 있다고 한다. RNN은 시간이 지남에 따라 순서대로 이전 내용을 잃기 시작한다.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;/assets/images/DeepLearning/RNN.png&quot; width=&quot;80%&quot; /&gt;&lt;/center&gt;

&lt;h2 id=&quot;lstm&quot;&gt;LSTM&lt;/h2&gt;
&lt;p&gt;LSTM은 일반적으로 입력, 출력 및 망각 게이트를 포함해 3개 또는 4개의 게이트로 구성된다. 입력 게이트는 일반적으로 들어오는 신호 또는 입력을 수용하거나 거부해 메모리 셀 상태를 변경한다. 출력 게이트는 일반적으로 필요에 따라 다른 뉴런에 값을 전달한다. 망각 게이트는 메모리 셀의 자기 반복 연결을 제어해 필요에 따라 이전 상태를 기억하거나 잊어버린다.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;/assets/images/DeepLearning/LSTM.png&quot; width=&quot;80%&quot; /&gt;&lt;/center&gt;

&lt;h2 id=&quot;nmt&quot;&gt;NMT&lt;/h2&gt;
&lt;p&gt;신경망 기반 기계 번역(Neural Machine Translation, NMT) 시스템은 일반적으로 인코더와 디코더 두 모듈로 구성된다. 먼저 인코더로 소스 문장을 읽고 생각 벡터를 만든다. 이 벡터는 문장의 의미를 나타내는 숫자의 시퀀스로 구성된다. 디코더는 문장 벡터를 처리해 다른 타깃 언어로 번역을 출력한다. 이를 인코더-디코더 아키텍처라고 한다.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;/assets/images/DeepLearning/NMT.jpg&quot; width=&quot;50%&quot; /&gt;&lt;/center&gt;

&lt;h2 id=&quot;gru&quot;&gt;GRU&lt;/h2&gt;
&lt;p&gt;게이트 순환 유닛(Gated Recurrent Units, GRU)은 LSTM과 관련이 있다. 둘 다 게이트 정보의 다른 방법을 사용해 기울기 소멸 문제를 방지하고 장기 메모리에 저장한다. GRU에는 두 개의 게이트가 있는데, 리셋 게이트 r과 업데이트 게이트 z다 . 리셋 게이트는 새 입력을 어떻게 이전의 은닉상태와 결합할 것인지 결정하고 업데이트 게이트는 유지할 이전 상태 정보의 양을 정의한다.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;/assets/images/DeepLearning/GRU.png&quot; width=&quot;50%&quot; /&gt;&lt;/center&gt;

&lt;blockquote&gt;
  &lt;p&gt;출처: 딥러닝 전이학습, “위키북스”&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Jaehoon Lee</name><email>machianb@naver.com</email></author><category term="Deep Learning" /></entry><entry><title type="html">우분투 쿠버네티스 설치</title><link href="http://localhost:4000/ubuntu/ubuntu_kubernetes_install/" rel="alternate" type="text/html" title="우분투 쿠버네티스 설치" /><published>2019-11-28T00:00:00+09:00</published><updated>2019-11-28T00:00:00+09:00</updated><id>http://localhost:4000/ubuntu/ubuntu_kubernetes_install</id><content type="html" xml:base="http://localhost:4000/ubuntu/ubuntu_kubernetes_install/">&lt;h1 id=&quot;우분투-환경에서-쿠버네티스-설치하기dashboard-까지&quot;&gt;우분투 환경에서 쿠버네티스 설치하기(dashboard 까지)&lt;/h1&gt;

&lt;p&gt;쿠버네티스를 설치하는 방법은 OS나 사용하는 플랫폼에 따라서 달라진다. &lt;br /&gt;
본 포스팅에서는 우분투 환경에서 쿠버네티스를 설치하고 추가적으로 쿠버네티스 대시보드까지 설치해 보도록 하겠다. &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;실행 환경: Ubuntu 18.04(LTS)&lt;/code&gt; &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;도커 버전: 19.03&lt;/code&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;쿠버네티스의 &lt;a href=&quot;https://kubernetes.io/ko/docs/setup/&quot;&gt;한글 문서&lt;/a&gt; 에 보면 공식적으로 지원하는 커뮤니티와 생태계를 확인할 수 있다. &lt;br /&gt;
윈도우의 경우에는 &lt;strong&gt;Docker Desktop&lt;/strong&gt; 을 설치하면 되겠구나 하는 생각이 들지만 나머지는 어떤걸 설치해야할지 막막해 진다. &lt;br /&gt;
모든 생태계 마다 설치하는 방법이 링크를 통해 설명되어 있으니 자신이 원하는 생태계를 선택하면 될 것 같다. &lt;br /&gt;
본인은 이중에서 &lt;a href=&quot;https://ubuntu.com/kubernetes/install#multi-node&quot;&gt;ubuntu.com&lt;/a&gt; 에 나온 MicroK8s를 사용하여 설치 해보았다 &lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Install the microk8s snap
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo snap install microk8s --classic
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Check the status
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo microk8s.status --wait-ready
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Turn on standard services
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo microk8s.enable dns dashboard registry
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;MicroK8s를 통해 kubectl 명령을 다음과 같이 수행할 수 있다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ microk8s.kubectl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이제 kubernetes dashboad를 설치하러 가보자
대시보드 UI는 기본으로 배포되지 않기 때문에 &lt;a href=&quot;https://kubernetes.io/ko/docs/tasks/access-application-cluster/web-ui-dashboard/&quot;&gt;쿠버네티스 대시보드 문서&lt;/a&gt; 를 참조하여 설치해 보도록 하겠다&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Install kubenetes dashboard
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ microk8s.kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta4/aio/deploy/recommended.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;설치가 종료되면 접속을 위한 토큰을 아래 명령을 통해 미리 생성해 둔다&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Bearer Token
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ microk8s.kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk '{print $1}')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;이 명령을 입력하면 아래와 같이 토큰이 나온다 &lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Name:         admin-user-token-v57nw
Namespace:    kubernetes-dashboard
Labels:       &amp;lt;none&amp;gt;
Annotations:  kubernetes.io/service-account.name: admin-user
              kubernetes.io/service-account.uid: 0303243c-4040-4a58-8a47-849ee9ba79c1

Type:  kubernetes.io/service-account-token

Data
====
ca.crt:     1066 bytes
namespace:  20 bytes
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi11c2VyLXRva2VuLXY1N253Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImFkbWluLXVzZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiIwMzAzMjQzYy00MDQwLTRhNTgtOGE0Ny04NDllZTliYTc5YzEiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZXJuZXRlcy1kYXNoYm9hcmQ6YWRtaW4tdXNlciJ9.Z2JrQlitASVwWbc-s6deLRFVk5DWD3P_vjUFXsqVSY10pbjFLG4njoZwh8p3tLxnX_VBsr7_6bwxhWSYChp9hwxznemD5x5HLtjb16kI9Z7yFWLtohzkTwuFbqmQaMoget_nYcQBUC5fDmBHRfFvNKePh_vSSb2h_aYXa8GV5AcfPQpY7r461itme1EXHQJqv-SN-zUnguDguCTjD80pFZ_CmnSE1z9QdMHPB8hoB4V68gtswR1VLa6mSYdgPwCHauuOobojALSaMc3RH7MmFUumAgguhqAkX3Omqd3rJbYOMRuMjhANqd08piDC3aIabINX6gP5-Tuuw2svnV6NYQ
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;토큰이 생성되었다면 프록시 명령을 통해 대시보드를 사용할 수 있다&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;kubectl proxy
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ microk8s.kubectl proxy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그리고 &lt;a href=&quot;http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/&quot;&gt;http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/&lt;/a&gt; 에 접속하여 token을 입력하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://d33wubrfki0l68.cloudfront.net/5f56e7ac82f10f46e70403a246c2b93efcf8b5b3/1c09f/images/docs/ui-dashboard-zerostate.png&quot; alt=&quot;웰컴 뷰&quot; /&gt;&lt;/p&gt;

&lt;p&gt;짜잔~! 대시보드를 확인할 수 있다&lt;/p&gt;</content><author><name>Jaehoon Lee</name><email>machianb@naver.com</email></author><category term="Ubuntu" /><category term="Docker" /><category term="Kubernetes" /><category term="Dashboard" /></entry><entry><title type="html">GAN 메인</title><link href="http://localhost:4000/deeplearning/gan_main/" rel="alternate" type="text/html" title="GAN 메인" /><published>2019-11-27T00:00:00+09:00</published><updated>2019-11-27T00:00:00+09:00</updated><id>http://localhost:4000/deeplearning/gan_main</id><content type="html" xml:base="http://localhost:4000/deeplearning/gan_main/">&lt;h1 id=&quot;생산적-적대-신경망generative-adversarial-networks-gan&quot;&gt;생산적 적대 신경망(generative adversarial networks, GAN)&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;두 개 이상의 신경망이 서로를 향하게 하고, 서로 대항하듯이 훈련하게 함으로써, 결과적으로&lt;br /&gt; &lt;strong&gt;생성 모델(generative model)&lt;/strong&gt; 을 산출해 낸다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://static.packt-cdn.com/products/9781789139907/graphics/1908d2b2-c04a-408d-9baf-f22b1bec49a0.png&quot; alt=&quot;GAN architecture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;GAN의 구조는 생성기(generator)와 판별기(discriminator)라고 부르는 두 가지 신경망으로 구성되어 있다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;생성기: 잠재 공간(latent space)에서 표본(samples)을 추출해 잠재 공간과 출력 간의 관계를 생성하는 역할 &lt;br /&gt; *한 모델 안에서 생성기와 판별기를 서로 연결해 적대 모드(adversarial mode)를 취하게 함으로써 생성기를 훈련&lt;/li&gt;
  &lt;li&gt;판별기: 생성기를 훈련함으로써 훈련된 판별기와 서로 균형을 잡는 방법을 학습 &lt;br /&gt; &lt;em&gt;판별기가 너무 뛰어나면 생성기가 발산(알아보기 힘든 데이터를 생성)&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gan-출력&quot;&gt;GAN 출력&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Style transfer: 입력 이미지에 특정 스타일을 적용시키는 방법으로 적은 사례(examples)을 요구하는 것이 특징&lt;/li&gt;
  &lt;li&gt;DCGAN(deep convolution GAN): 입력 구문(input phrase)을 통해 출력 이미지를 생성&lt;/li&gt;
  &lt;li&gt;SimGAN: 모조 이미지(simulated image)를 통해 레이블이 붙은 데이터를 자동으로 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;/network_1/&quot; class=&quot;btn btn--success btn--large&quot;&gt;네트워크 1장&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;출처: 실전 예제로 배우는 GAN, “위키북스”&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Jaehoon Lee</name><email>machianb@naver.com</email></author><category term="Deep Learning" /><category term="GAN" /><category term="generative adversarial networks" /></entry><entry><title type="html">우분투 도커 설치</title><link href="http://localhost:4000/ubuntu/ubuntu_docker_install/" rel="alternate" type="text/html" title="우분투 도커 설치" /><published>2019-11-27T00:00:00+09:00</published><updated>2019-11-27T00:00:00+09:00</updated><id>http://localhost:4000/ubuntu/ubuntu_docker_install</id><content type="html" xml:base="http://localhost:4000/ubuntu/ubuntu_docker_install/">&lt;h1 id=&quot;우분투-도커-설치이미지-폴더-변경-까지&quot;&gt;우분투 도커 설치(이미지 폴더 변경 까지)&lt;/h1&gt;

&lt;p&gt;우분투 환경에서 도커를 설치하는 방법을 정리해 보고자 한다. 
실행 환경: Ubuntu 18.04(LTS)
도커 버전: 19.03&lt;/p&gt;

&lt;p&gt;도커 설치 과정은  &lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce/ubuntu/&quot;&gt;docs.docker.com&lt;/a&gt; 를 참고하여 순서대로 설명해 보겠다.&lt;/p&gt;

&lt;h2 id=&quot;1-uninstall-old-versions&quot;&gt;1. Uninstall old versions&lt;/h2&gt;
&lt;p&gt;기존에 도커가 설치되어 있다면 도커를 삭제하고 도커 폴더 역시 삭제한다.&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 도커 삭제
$ sudo apt-get remove docker docker-engine docker.io containerd runc

# 도커 폴더 삭제
$ sudo rm -rf /var/lib/docker
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;2-set-up-the-repository&quot;&gt;2. Set up the repository&lt;/h2&gt;
&lt;p&gt;도커 엔진을 설치하기 전에 새로운 기기에 도커 저장소를 설정하여 도커를 설치 및 업데이트 한다&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# apt 패키지 업데이트
$ sudo apt-get update

# HTTPS를 통해 저장소를 사용하기 쉬운 패키지 설치
$ sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg-agent \
    software-properties-common
		
# 도커의 공식 GPG key 추가하기(생략 가능)
$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
$ sudo apt-key fingerprint 0EBFCD88
    
pub   rsa4096 2017-02-22 [SCEA]
      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88
uid           [ unknown] Docker Release (CE deb) &amp;lt;docker@docker.com&amp;gt;
sub   rsa4096 2017-02-22 [S]

# 안정적인 저장소 설정하기
$ sudo add-apt-repository \
   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3-install-docker-ce&quot;&gt;3. Install docker-CE&lt;/h2&gt;
&lt;p&gt;이제 도커를 설치해보자&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# apt 패키지 업데이트 수행
$ sudo apt-get update

# 최신 도커 설치
$ sudo apt-get install docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;31-install-nvidia-docker2option&quot;&gt;3.1 Install nvidia-docker2(Option)&lt;/h3&gt;
&lt;p&gt;추가적으로 nvidia-docker를 설치한다&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install nvidia-docker2
$ sudo pkill -SIGHUP dockerd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;일반적으로 도커를 사용하는데 있어서 위의 절차까지 수행하면 크게 문제가 없다. &lt;br /&gt;
&lt;strong&gt;하지만&lt;/strong&gt; 도커의 이미지의 크기는 매우 크기 때문에 하드드라이브가 가득 차서 더이상 설치할 수 없게 된다. &lt;br /&gt;
그렇게 되지 않기 위하여 &lt;strong&gt;도커를 사용하면서 사용하지 않는 이미지나 컨테이너를 주기적으로 관리&lt;/strong&gt;해 주어야 하지만 대부분의 OS가 설치된 하드는 SSD이고 용량이 상대적으로 적기 때문에 &lt;strong&gt;도커 이미지 위치를 HDD로 변경&lt;/strong&gt;하여 사용한다&lt;/p&gt;

&lt;h2 id=&quot;4-docker-default-folder-change&quot;&gt;4. Docker default folder change&lt;/h2&gt;
&lt;p&gt;도커 폴더 변경은 &lt;a href=&quot;https://yookeun.github.io/docker/2018/10/29/docker-change/&quot;&gt;이곳&lt;/a&gt; 을 참조하였다. &lt;br /&gt; 2가지 방법이 나오는데 1번 방법(도커 실행 서비스에서 설정 변경)을 사용하였다&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/systemd/system/docker.service&lt;/code&gt; 파일을 열고 아래 내용을 수정한다&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#ExecStart=/usr/bin/dockerd -H fd://
ExecStart=/usr/bin/dockerd -g /media/username/data/docker -H fd://
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/media/username/data/docker&lt;/code&gt; 이 경로를 자신의 폴더 경로로 변경한다&lt;/p&gt;

&lt;p&gt;도커를 중지하고 기본 도커 폴더의 내용을 이동&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 기본 폴더안의 내용을 옮기기 위해 docker를 중지
$ sudo systemctl stop docker
$ sudo systemctl daemon-reload

# 기존 도커 경로의 파일을 복사
$ sudo rsync -aqxP /var/lib/docker /media/username/data/docker
$ sudo rm -rf /var/lib/docker

# 도커 시작 및 확인
$ sudo systemctl start docker
$ ps -ef | grep docker
root      1442     1  0 11월27 ?      00:00:05 /usr/bin/dockerd -g /media/username/data/docker -H fd://
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자신이 설정한 경로가 출력되는지 확인한다면 정상적으로 변경되었고 이제 마음것(?) 이미지를 생성할 수 있다!&lt;/p&gt;</content><author><name>Jaehoon Lee</name><email>machianb@naver.com</email></author><category term="Ubuntu" /><category term="Docker" /></entry><entry><title type="html">네트워크 메인</title><link href="http://localhost:4000/networks/network_main/" rel="alternate" type="text/html" title="네트워크 메인" /><published>2019-11-26T00:00:00+09:00</published><updated>2019-11-26T00:00:00+09:00</updated><id>http://localhost:4000/networks/network_main</id><content type="html" xml:base="http://localhost:4000/networks/network_main/">&lt;h1 id=&quot;네트워크와-관련된-내용을-포스팅-해갈-예정입니다&quot;&gt;네트워크와 관련된 내용을 포스팅 해갈 예정입니다&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;/network_1/&quot; class=&quot;btn btn--success btn--large&quot;&gt;네트워크 1장&lt;/a&gt;&lt;/p&gt;</content><author><name>Jaehoon Lee</name><email>machianb@naver.com</email></author><category term="Networks" /></entry><entry><title type="html">네트워크 1장</title><link href="http://localhost:4000/networks/network_1/" rel="alternate" type="text/html" title="네트워크 1장" /><published>2019-11-19T00:00:00+09:00</published><updated>2019-11-19T00:00:00+09:00</updated><id>http://localhost:4000/networks/network_1</id><content type="html" xml:base="http://localhost:4000/networks/network_1/">&lt;h2 id=&quot;lesson-1-정리&quot;&gt;Lesson 1 정리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;컴퓨터 간의 연결을 컴퓨터 네트워크라고 부른다&lt;/li&gt;
  &lt;li&gt;인터넷은 전 세계의 큰 네트워크부터 작은 네트워크까지 연결하는 거대한 네트워크다&lt;/li&gt;
  &lt;li&gt;패킷은 컴퓨터 간의 데이터를 주고받을 때 네트워크를 통해 흘러가는 작은 데이터 조각이다&lt;/li&gt;
  &lt;li&gt;큰 데이터는 작은 패킷으로 분할한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;lesson-2-정리&quot;&gt;Lesson 2 정리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;컴퓨터는 0과 1밖에 이해하지 못한다&lt;/li&gt;
  &lt;li&gt;정보를 나타내는 최소 단위를 비트라고 하며, 비트 여덟 개를 1바이트라고 한다&lt;/li&gt;
  &lt;li&gt;숫자와 문자의 대응표를 문자코드라고 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;lesson-3-정리&quot;&gt;Lesson 3 정리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;건물 안이나 특정 지역을 범위로 하는 네트워크를 랜(Local Area Network, LAN)이라고 한다&lt;/li&gt;
  &lt;li&gt;인터넷 서비스 제공자(ISP)가 제공하는 서비스를 사용하여 구축한 네트워크를 왠(Wide Area Network, WAN)이라고 한다&lt;/li&gt;
  &lt;li&gt;랜은 왠보다 범위가 좁고 속도가 빠르며 오류가 발생할 확률이 낮다&lt;/li&gt;
  &lt;li&gt;왠은 랜보다 버무이가 넓고 속도가 느리며 오류가 발생할 확률이 높다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;lesson-4-정리&quot;&gt;Lesson 4 정리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;우선 인터넷 서비스 제공자와 인터넷회선을 결정하고 계약한다&lt;/li&gt;
  &lt;li&gt;인터넷 서비스 제공자와 인터넷 공유기로 접속한다&lt;/li&gt;
  &lt;li&gt;접속 방식에는 유선 랜 방식과 무선 랜 방식이 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;lesson-5-정리&quot;&gt;Lesson 5 정리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;DMZ는 외부에 공개하기 위한 네트워크다&lt;/li&gt;
  &lt;li&gt;외부에 공개하는 서버에는 주로 웹 서버, DNS 서버, 메일 서버가 있다&lt;/li&gt;
  &lt;li&gt;회사의 서버는 온프레미스나 클라우드로 운영되고 있다&lt;/li&gt;
  &lt;li&gt;각 서버나 컴퓨터는 스위치나 무선 랜 기능을 사용하여 사내 랜에 접속한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;용어-정리&quot;&gt;용어 정리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;네트워크&lt;/strong&gt;: 컴퓨터를 두 대 이상 연결하여 서로 데이터를 전송할 수 있는 통신망&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인터넷&lt;/strong&gt;: TCP/IP 프로토콜을 사용하는 세계 최대 규모의 네트워크다. 전 세계의 컴퓨터를 서로 연결하여 정보를 교환할 수 있도록 만든 하나의 거대한 컴퓨터 통신망이다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;패킷&lt;/strong&gt;: 네트워크 통신을 할 때 사용되는 작게 분할된 데이터 조각으로 네트워크에서 전송하는 데이터의 기본 단위다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비트&lt;/strong&gt;: 정보의 최소 단위로 0 또는 1을 나타낸다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;바이트&lt;/strong&gt;: 컴퓨터의 정보량 단위로 8비트를 1바이트라고 한다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;랜&lt;/strong&gt;: 비교적 가까운 거리에 위치한 장치들을 서로 연결한 네트워크를 말한다. 집, 사무실, 학교 등의 건물과 같이 가까운 지역을 연결하는 네트워크다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;왠&lt;/strong&gt;: 랜을 다시 하나로 묶은 거대한 네트워크다. 특정 도시, 국가, 대륙과 같이 매우 넓은 범위를 연결하는 네트워크를 말한다. 넓은 지역에 설치된 컴퓨터들 간의 정보와 자원을 공유하기에 적합하도록 설계한 컴퓨터 통신망이다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인터넷 서비스 제공자&lt;/strong&gt;: 인터넷에 접속하는 수단을 제공하는 주체다. 일반 사용자, 기업체, 기관, 단체 등이 인터넷에 접속하여 인터넷을 이용할 수 있도록 돕는 사업자다. 현재는 KT, U+, SK브로드밴드와 같은 ISP가 인터넷 서비스를 제공한다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;서버&lt;/strong&gt;: 컴퓨터 네트워크에서 다른 컴퓨터에 서비스를 제공하기 위한 컴퓨터 또는 프로그램이다&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Jaehoon Lee</name><email>machianb@naver.com</email></author><category term="Networks" /></entry></feed>